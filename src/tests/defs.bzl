load("@bazel_skylib//lib:dicts.bzl", "dicts")
load("@rules_dotnet//dotnet:defs.bzl", "compile_csharp_exe")
load("@rules_dotnet//dotnet/private/transitions:tfm_transition.bzl", "tfm_transition")
load("@rules_dotnet//dotnet/private/rules/common:attrs.bzl", "CSHARP_BINARY_COMMON_ATTRS")
load(
    "@rules_dotnet//dotnet/private:providers.bzl",
    "DotnetApphostPackInfo",
    "DotnetBinaryInfo",
    "DotnetRuntimePackInfo",
    "DotnetAssemblyCompileInfo",
    "DotnetAssemblyRuntimeInfo",
)
load("@rules_dotnet//dotnet/private/transitions:default_transition.bzl", "default_transition")
load(
    "@rules_dotnet//dotnet/private:common.bzl",
    "collect_transitive_runfiles",
    "generate_depsjson",
    "generate_runtimeconfig",
    "is_core_framework",
    "is_standard_framework",
    "to_rlocation_path",
)
load("@rules_dotnet//dotnet/private/macros:register_tfms.bzl", "get_tfm_value")
load("@rules_dotnet//dotnet/private/sdk/targeting_packs:targeting_pack_transition.bzl", "targeting_pack_transition")
load("//:defs.bzl", "NETCOREAPP_TOOL_CURRENT", "LIVE_REFPACK_DEPS")

def _live_csharp_binary_impl(ctx):
    result = _build_binary(ctx, compile_csharp_exe)
    return result

live_csharp_binary = rule(
    _live_csharp_binary_impl,
    doc = """Compile a C# exe for the live framework""",
    attrs = dicts.add({
        "deps": attr.label_list(
            doc = "Other libraries, binaries, or imported DLLs",
            providers = [DotnetAssemblyCompileInfo, DotnetAssemblyRuntimeInfo],
            cfg = tfm_transition,
        ),
        "data": attr.label_list(
            doc = "Runtime files. It is recommended to use the @rules_dotnet//tools/runfiles library to read the runtime files.",
            allow_files = True,
            default = [],
            allow_empty = True,
            # We transition to the default configuration because the end user might have dotnet binaries
            # in their data and we want the TFM graphs to be disconnected
            cfg = default_transition,
        ),
        "compile_data": attr.label_list(
            doc = "Additional compile time files.",
            allow_files = True,
            default = [],
            allow_empty = True,
            # We transition to the default configuration because the end user might have dotnet binaries
            # in their compile_data and we want the TFM graphs to be disconnected
            cfg = default_transition,
        ),
        "appsetting_files": attr.label_list(
            doc = "A list of appsettings files to include in the output directory.",
            allow_files = True,
            default = [],
            allow_empty = True,
            # We transition to the default configuration because the end user might have dotnet binaries
            # in their appsetting_files and we want the TFM graphs to be disconnected
            cfg = default_transition,
        ),
        "srcs": attr.label_list(
            doc = "The source files used in the compilation.",
            allow_files = [".cs"],
            # We transition to the default configuration because the end user might have srcs
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "out": attr.string(
            doc = "File name, without extension, of the built assembly.",
        ),
        "project_sdk": attr.string(
            doc = "The project SDK that is being targeted. " +
                "See https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview",
            default = "default",
            values = ["default", "web"],
        ),
        "generate_documentation_file": attr.bool(
            doc = "Whether or not to generate a documentation file.",
            default = True,
        ),
        "defines": attr.string_list(
            doc = "A list of preprocessor directive symbols to define.",
            default = [],
            allow_empty = True,
        ),
        "internals_visible_to": attr.string_list(
            doc = "Other libraries that can see the assembly's internal symbols. Using this rather than the InternalsVisibleTo assembly attribute will improve build caching.",
        ),
        "assembly_version": attr.string(
            doc = "The assembly version.",
        ),
        "cls_compliant": attr.bool(
            doc = "Whether the assembly is CLS compliant.",
            default = True,
        ),
        "keyfile": attr.label(
            doc = "The key file used to sign the assembly with a strong name.",
            allow_single_file = True,
            # We transition to the default configuration because the end user might have a keyfile
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "langversion": attr.string(
            doc = "The version string for the language.",
        ),
        "resources": attr.label_list(
            doc = "A list of files to embed in the DLL as resources.",
            allow_files = True,
            # We transition to the default configuration because the end user might have resources
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "additionalfiles": attr.label_list(
            doc = "Extra files to configure analyzers.",
            allow_files = True,
            # We transition to the default configuration because the end user might have additional files
            # that is generated by a dotnet binary
            cfg = default_transition,
        ),
        "analyzers": attr.label_list(
            doc = "Additional analyzer assemblies.",
            providers = [DotnetAssemblyCompileInfo, DotnetAssemblyRuntimeInfo],
        ),
        "treat_warnings_as_errors": attr.bool(
            doc = "Treat all compiler warnings as errors. Note that this attribute can not be used in conjunction with warnings_as_errors.",
            mandatory = False,
            default = False,
        ),
        "target_frameworks": attr.string_list(
            doc = "A list of target framework monikers to build" +
                "See https://docs.microsoft.com/en-us/dotnet/standard/frameworks",
            mandatory = True,
            allow_empty = False,
        ),
        "disable_implicit_framework_refs": attr.bool(
            doc = "Disable implicit framework references. This is useful when you want to control the framework references yourself.",
            default = True,
        ),
        "warnings_as_errors": attr.string_list(
            doc = "List of compiler warning codes that should be considered as errors. Note that this attribute can not be used in conjunction with treat_warning_as_errors.",
            mandatory = False,
            default = [],
        ),
        "warnings_not_as_errors": attr.string_list(
            doc = "List of compiler warning codes that should not be considered as errors. Note that this attribute can only be used in conjunction with treat_warning_as_errors.",
            mandatory = False,
            default = [],
        ),
        "warning_level": attr.int(
            doc = "The warning level that should be used by the compiler.",
            mandatory = False,
            values = [0, 1, 2, 3, 4, 5],
            default = 3,
        ),
        "nowarn": attr.string_list(
            doc = "List of warnings that should be ignored",
            mandatory = False,
            default = ["CS1701", "CS1702"],
        ),
        "allow_unsafe_blocks": attr.bool(
            doc = "Allow compiling unsafe code. It true, /unsafe is passed to the compiler.",
            mandatory = False,
            default = False,
        ),
        "nullable": attr.string(
            doc = "Enable nullable context, or nullable warnings.",
            mandatory = False,
            default = "disable",
            values = ["disable", "enable", "warnings", "annotations"],
        ),
        "run_analyzers": attr.bool(
            doc = "Controls whether analyzers run at build time.",
            mandatory = False,
            default = True,
        ),
        "compiler_options": attr.string_list(
            doc = "Additional options to pass to the compiler. This attribute should only be used if the compiler flag has not already been exposed as an attribute.",
            mandatory = False,
            default = [],
        ),
        "roll_forward_behavior": attr.string(
            doc = "The roll forward behavior that should be used: https://learn.microsoft.com/en-us/dotnet/core/versions/selection#control-roll-forward-behavior",
            default = "Major",
            values = ["Minor", "Major", "LatestPatch", "LatestMinor", "LatestMajor", "Disable"],
        ),
        "_target_framework": attr.label(
            default = "@rules_dotnet//dotnet:target_framework",
        ),
        "_windows_constraint": attr.label(default = "@platforms//os:windows"),
        "_compiler_wrapper_sh": attr.label(
            default = "@rules_dotnet//dotnet/private:compiler_wrapper.sh",
            executable = True,
            cfg = "exec",
            allow_single_file = True,
        ),
        "_compiler_wrapper_bat": attr.label(
            default = "@rules_dotnet//dotnet/private:compiler_wrapper.bat",
            executable = True,
            cfg = "exec",
            allow_single_file = True,
        ),
        "_bash_runfiles": attr.label(
            default = "@bazel_tools//tools/bash/runfiles",
            allow_single_file = True,
        ),
        "_targeting_pack": attr.label(
            default = "@rules_dotnet//dotnet/private/sdk/targeting_packs:targeting_pack",
            cfg = targeting_pack_transition,
        ),
        "_launcher_sh": attr.label(
            doc = "A template file for the launcher on Linux/MacOS",
            default = "//:eng/run_test.sh",
            allow_single_file = True,
        ),
        "_core_root": attr.label(
            doc = "The host binary to use for the launcher",
            default = "//:Core_Root",
            allow_single_file = True,
        ),
        "include_host_model_dll": attr.bool(
            doc = "Whether to include Microsoft.NET.HostModel from the toolchain. This is only required to build tha apphost shimmer.",
            default = False,
        ),
    }),
    executable = True,
    toolchains = [
        "@rules_dotnet//dotnet:toolchain_type",
    ],
    cfg = tfm_transition,
)

def _create_launcher(ctx, runfiles, entry_dll):
    windows_constraint = ctx.attr._windows_constraint[platform_common.ConstraintValueInfo]

    launcher = ctx.actions.declare_file("{}.{}".format(entry_dll.basename, "bat" if ctx.target_platform_has_constraint(windows_constraint) else "sh"), sibling = entry_dll)

    ctx.actions.expand_template(
        template = ctx.file._launcher_sh,
        output = launcher,
        substitutions = {
            "TEMPLATED_core_root": to_rlocation_path(ctx, ctx.file._core_root),
            "TEMPLATED_entry_dll": to_rlocation_path(ctx, entry_dll),
        },
        is_executable = True,
    )
    runfiles.append(ctx.file._core_root)
    runfiles.append(ctx.file._bash_runfiles)

    return launcher

def _build_binary(ctx, compile_action):
    """Builds a .Net binary from a compilation action

    Args:
        ctx: Bazel build ctx.
        compile_action: A compilation function
            Args:
                ctx: Bazel build ctx.
                tfm: Target framework string
            Returns:
                An DotnetAssemblyInfo provider
    Returns:
        A collection of the references, runfiles and native dlls.
    """
    tfm = get_tfm_value(ctx.attr._target_framework)

    if is_standard_framework(tfm):
        fail("It doesn't make sense to build an executable for " + tfm)

    (compile_provider, runtime_provider) = compile_action(ctx, tfm)
    dll = runtime_provider.libs[0]
    default_info_files = [dll] + runtime_provider.xml_docs + runtime_provider.appsetting_files.to_list()
    additional_runfiles = []

    launcher = _create_launcher(ctx, additional_runfiles, dll)

    runtimeconfig = None
    depsjson = None
    transitive_runtime_deps = runtime_provider.deps.to_list()

    if is_core_framework(tfm):
        # Create the runtimeconfig.json for the binary
        runtimeconfig = ctx.actions.declare_file("%s/%s/%s.runtimeconfig.json" % (ctx.label.name, tfm, ctx.attr.out or ctx.attr.name))
        runtimeconfig_struct = generate_runtimeconfig(
            target_framework = tfm,
            project_sdk = ctx.attr.project_sdk,
            is_self_contained = False,
            roll_forward_behavior = ctx.attr.roll_forward_behavior,
        )

        ctx.actions.write(
            output = runtimeconfig,
            content = json.encode_indent(runtimeconfig_struct),
        )

        depsjson = ctx.actions.declare_file("%s/%s/%s.deps.json" % (ctx.label.name, tfm, ctx.attr.out or ctx.attr.name))
        depsjson_struct = generate_depsjson(
            ctx,
            target_framework = tfm,
            is_self_contained = False,
            target_assembly_runtime_info = runtime_provider,
            transitive_runtime_deps = transitive_runtime_deps,
            use_relative_paths = True,
        )

        ctx.actions.write(
            output = depsjson,
            content = json.encode_indent(depsjson_struct),
        )

    if runtimeconfig != None:
        additional_runfiles.append(runtimeconfig)

    if depsjson != None:
        additional_runfiles.append(depsjson)

    default_info = DefaultInfo(
        executable = launcher,
        runfiles = collect_transitive_runfiles(ctx, runtime_provider, ctx.attr.deps).merge(ctx.runfiles(files = additional_runfiles)),
        files = depset(default_info_files),
    )

    return [default_info, compile_provider, runtime_provider]

def coreclr_test(
    name,
    srcs,
    **kwargs
):
    live_csharp_binary(
        name = name,
        srcs = srcs,
        **kwargs
    )

def coreclr_merged_test(
    name,
    **kwargs
):
    live_csharp_binary(
        name = name,
        target_frameworks = ["net9.0"],
        **kwargs
    )
